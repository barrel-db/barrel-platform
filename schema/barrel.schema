%%-*- mode: erlang -*-
%% HTTP Listeners
%% @doc listener.http.<name> is an IP address and TCP port that the Riak
%% HTTP interface will bind.

{mapping, "listener.http.$name", "barrel.api.http",[
  {default, { "{{web_ip}}", {{web_port}} }},
  {datatype, ip},
  {include_default, "default"}
 ]}.

{translation,
 "barrel.api.http",
 fun(Conf) ->
     HTTP = cuttlefish_variable:filter_by_prefix("listener.http", Conf),
     [ IP || {_, IP} <- HTTP]
 end
}.

%% @doc listener.https.<name> is an IP address and TCP port that the Riak
%% HTTPS interface will bind.
{mapping, "listener.https.$name", "barrel.api.https", [
  {commented, {"{{web_ip}}",{{web_port}} }},
  {datatype, ip},
  {include_default, "default"}
]}.

{translation,
 "barrel.api.https",
 fun(Conf) ->
     HTTPS = cuttlefish_variable:filter_by_prefix("listener.https", Conf),
     [ IP || {_, IP} <- HTTPS]
 end
}.

%% @doc The maximum length to which the queue of pending connections
%% may grow. If set, it must be an integer > 0. If you anticipate a
%% huge number of connections being initialized *simultaneously*, set
%% this number higher.
{mapping, "backlog", "barrel.api.backlog", [
  {datatype, integer},
  {default, 2048},
  {commented, 2048},
  {validators, ["greater_than_zero"]}
]}.

%% @doc The maximum number of connection accepted by a listener.
{mapping, "max_connections", "barrel.api.max_connections", [
  {datatype, integer},
  {default, 10000},
  {commented, 10000},
  {validators, ["greater_than_zero"]}
]}.

%% @doc The number of workefr waiting for a connection.
{mapping, "nb_acceptors", "barrel.api.nb_acceptors", [
  {datatype, integer},
  {default, 10},
  {commented, 10},
  {validators, ["greater_than_zero"]}
]}.


{validator,
 "greater_than_zero",
 "must be greater than zero",
 fun(Value) -> Value > 0 end}.

{validator,
 "greater_than_zero",
 "must be greater than zero",
 fun(Value) -> Value > 0 end}.

%% @doc Whether to prefer the order in which the server lists its
%% ciphers. When set to 'off', the client's preferred cipher order
%% dictates which cipher is chosen.
{mapping, "honor_cipher_order", "barrel.api.honor_cipher_order", [
  {datatype, {enum, [on, off]}},
  {default, on},
  hidden
]}.

{translation,
  "barrel.api.honor_cipher_order",
   fun(Conf) ->
     OTPVer = erlang:system_info(otp_release),
     CipherOrder = cuttlefish:conf_get("honor_cipher_order", Conf),
     %% This is only available, as of December 2013, in basho patched R16B02,
     %% so disable it if the VM is not patched by basho. This can be revised
     %% for R17, when this patch is expected to be present mainline.
     %% The basho patched OTP can be found at:
     %% https://github.com/basho/otp/tree/OTP_R16B02_basho3
     case {CipherOrder, string:str(OTPVer, "basho")} of
       {_, 0} -> false;
       {on, _} -> true;
       {off, _} -> false
     end
   end
}.

%% @doc Determine which SSL/TLS versions are allowed. By default only TLS 1.2
%% is allowed, but other versions can be enabled if clients don't support the
%% latest TLS standard. It is *strongly* recommended that SSLv3 is not enabled
%% unless absolutely necessary. More than one protocol can be enabled at once.
{mapping, "tls_protocols.sslv3", "barrel.api.tls_protocols", [
  {datatype, {enum, [on, off]}},
  {default, off},
  hidden
]}.

%% @see tls_protocols.sslv3
{mapping, "tls_protocols.tlsv1", "barrel.api.tls_protocols", [
  {datatype, {enum, [on, off]}},
  {default, off},
  hidden
]}.

%% @see tls_protocols.sslv3
{mapping, "tls_protocols.tlsv1.1", "barrel.api.tls_protocols", [
  {datatype, {enum, [on, off]}},
  {default, off},
  hidden
]}.

%% @see tls_protocols.sslv3
{mapping, "tls_protocols.tlsv1.2", "barrel.api.tls_protocols", [
  {datatype, {enum, [on, off]}},
  {default, on},
  hidden
]}.

{translation,
 "barrel.api.tls_protocols",
 fun(Conf) ->
    Protocols = cuttlefish_variable:filter_by_prefix("tls_protocols", Conf),
    [begin
         case Key of
             ["tls_protocols","sslv3"] ->
                 sslv3;
             ["tls_protocols","tlsv1"] ->
                 tlsv1;
             ["tls_protocols","tlsv1", "1"] ->
                 'tlsv1.1';
             ["tls_protocols","tlsv1", "2"] ->
                 'tlsv1.2'
         end
     end || {Key, Value} <- Protocols, Value == on]
 end
}.

%% @doc Whether to check the CRL of a client certificate. This defaults to
%% on but some CAs may not maintain or define a CRL, so this can be disabled
%% if no CRL is available.
{mapping, "check_crl", "barrel.api.check_crl", [
  {datatype, {enum, [on, off]}},
  {default, on},
  hidden
]}.

{translation,
 "barrel.api.check_crl",
 fun(Conf) ->
     OTPVer = erlang:system_info(otp_release),
     CheckCRL = cuttlefish:conf_get("check_crl", Conf),
     %% CRL checking is broken in mainline OTP as of R16B02, so Riak will ship
     %% with a patched SSL/public_key to fix it. This means that we don't want
     %% to pass this option to a vanilla OTP.
     %% The basho patched OTP can be found at:
     %% https://github.com/basho/otp/tree/OTP_R16B02_basho3
     case {CheckCRL, string:str(OTPVer, "basho")} of
       {_, 0} -> false;
       {on, _} -> true;
       {off, _} -> false
     end
 end
}.
