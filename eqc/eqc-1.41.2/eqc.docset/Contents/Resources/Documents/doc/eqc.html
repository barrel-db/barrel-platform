<?xml version="1.0"?><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>Module eqc</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc"/>
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<hr/>

<h1>Module eqc</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module defines functions for writing and testing QuickCheck properties.
<p>Copyright Â© Quviq AB, 2004-2017</p>

<p><b>Version:</b> 1.41.2</p>

<h2><a name="description">Description</a></h2>This module defines functions for writing and testing QuickCheck properties.
 Much of the interface is provided via macros (defined in <tt>eqc.hrl</tt>).
 These are documented below:
 <h2><tt>?FORALL(X,Gen,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds for all values <tt>X</tt> that
 can be generated by <tt>Gen</tt>. For example,
 <pre>
 prop_reverse() -&gt;
   ?FORALL(Xs,list(int()),
      lists:reverse(lists:reverse(Xs)) == Xs).
 </pre>
 Generators are defined using the module <a href="eqc_gen.html"><code>eqc_gen</code></a>.
 <h2><tt>?IMPLIES(Pre,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds whenever the precondition
 <tt>Pre</tt> is true. The precondition must be a boolean, but <tt>Prop</tt>
 can be any QuickCheck property. An implication is tested by discarding test
 cases which do not satisfy the precondition. This can make testing slow,
 since many more test cases may need to be generated to find 100 which
 satisfy the precondition. In the worst case, QuickCheck may not be able
 to find enough test cases that do satisfy the precondition, in which case
 the number actually found is reported. Some preconditions may also skew
 the test data badly--for example, a precondition that a list is sorted
 skews the test data towards short lists, since random longer lists are
 extremely unlikely to be sorted just by chance. <tt>?IMPLIES</tt> works
 well for preconditions which are true with a high probability, but if the
 precondition is unlikely to hold, then it is better to write a custom
 generator which generates test cases where the precondition is true.
 <h2><tt>?WHENFAIL(Action,Prop)</tt></h2>
 Property that is equivalent to <tt>Prop</tt>, but performs <tt>Action</tt>
 (for its side effects) when <tt>Prop</tt> fails. This can be used to
 print additional information when a test case fails.
 <h2><tt>?TRAPEXIT(Prop)</tt></h2>
 A property which tests <tt>Prop</tt> in a separate process, trapping
 exits and treating them as test failures. QuickCheck always catches
 locally raised exceptions in properties, but when a test exits because
 a linked process fails, then the exit is NOT caught unless the body of
 the property is enclosed in ?TRAPEXIT. Shrinking is disabled
 for any ?FORALLs enclosed by ?TRAPEXIT (although not, of course, for
 ?FORALLs which enclose it). Thus ?TRAPEXIT would typically be
 used inside the innermost ?FORALL of a property.
 <p>
 Note that actions in the <tt>?WHENFAIL</tt> macro are not executed if
 they are inside a <tt>TRAPEXIT</tt>, thus one may have less printed
 information in the failing test case.
 When using <a href="eqc_component.html"><code>eqc_component</code></a> specifications there is an alternative
 to <tt>?TRAPEXIT</tt> by using a worker process instead.</p>
 <h2><tt>?TIMEOUT(Limit,Prop)</tt></h2>
 A property which tests <tt>Prop</tt> with a time limit of
 <tt>Limit</tt> milliseconds.  If the timeout is exceeded, then the
 property fails with the reason <tt>{timeout,Limit}</tt>.
 Note that
 any <tt>?FORALL</tt>s within the <tt>?TIMEOUT</tt> will <i>not</i>
 print the generated values, and moreover those values will <i>not</i> shrink
 on a test failure,
 so it is a good idea to nest
 <tt>?TIMEOUT</tt> within <tt>?FORALL</tt> rather than vice versa.
 <p><b>Example:</b>
 <pre>
 prop_sleep() -&gt;
   ?FORALL(N,choose(50,150),
     ?TIMEOUT(100,
       timer:sleep(N) == ok)).
 </pre>
 fails as follows:<pre>
 1&gt; eqc:quickcheck(foo:prop_sleep()).
 ....Failed! Reason:
 {'EXIT',{timeout,100}}
 After 5 tests.
 118
 Shrinking....(4 times)
 Reason:
 {'EXIT',{timeout,100}}
 101
 false
 </pre>
 where the length of the <tt>sleep</tt> shrinks to the minimal value
 required to time out, of course.
 </p>
 <h2><tt>?SETUP(Fun,Prop)</tt></h2>
 Similar to initializing a test suite, before running a QuickCheck test run, one might want to setup
 the subject under test.
 QuickCheck offers the <tt>?SETUP</tt> property
 for defining setup and teardown behaviour for one QuickCheck run (default hundred tests). The zero-arity
 function <tt>Fun</tt> is called before the property is checked. This functions should
 return a zero-arity teardown function which is called after the property has been checked.
 <br/>
 Example:
 <pre>
   prop_ok() -&gt;
      ?SETUP(fun() -&gt; setup_mocking(),
                  fun() -&gt; teardown_mocking() end
             end,
         ?FORALL(Cmds, commands(), ...)).
 </pre>
 <h2><tt>?ALWAYS(N,Prop)</tt></h2>
 A property which tests <tt>Prop</tt> repeatedly <tt>N</tt> times, failing
 as soon as any of the tests of <tt>Prop</tt> fails. Typically this is used
 as follows:
 <pre>?FORALL(X,...,?ALWAYS(N,?FORALL(Y,...,...)))</pre>
 which generates <tt>N</tt> values of <tt>Y</tt> for each value of <tt>X</tt>.
 This is useful if
 <ul>
 <li>Generating <tt>X</tt>, or changing <tt>X</tt> from test to
 test, is expensive--for example, if <tt>X</tt> is a configuration which
 is expensive to install, so that we want to run many tests for each
 configuration.
 </li>
 <li>
 We are trying to shrink <tt>X</tt>, but <tt>Y</tt> is generated from
 <tt>X</tt>, and most choices of <tt>Y</tt> make the test pass. In
 this situation, then shrinking is likely to fail, because whenever
 we try to shrink <tt>X</tt> to a smaller value, then we are likely
 to choose a <tt>Y</tt> that happens to make the test pass. Trying
 many values of <tt>Y</tt> makes it much more likely that one of them will
 fail, and so shrinking will succeed.
 </li>
 </ul>
 Don't use this macro at the top-level of a property: <a href="#numtests-2"><code>numtests/2</code></a> is more appropriate for this.
 <h2><tt>?SOMETIMES(N,Prop)</tt></h2>
 A property which tests <tt>Prop</tt> repeatedly <tt>N</tt> times,
 failing only if <i>all</i> of the tests fail. In other words, the
 property passes if <tt>Prop</tt> <i>sometimes</i> passes. This is
 used in situations where test outcomes are non-deterministic, to
 search for test cases that <i>consistently</i> fail. A property such
 as <tt>?FORALL(X,...,?SOMETIMES(10,...))</tt> will find test cases
 <tt>X</tt> for which the property inside <tt>?SOMETIMES</tt> is very
 likely to fail.
 <h2><tt>?ONCEONLY(Prop)</tt></h2>
 A property, logically equivalent to <tt>Prop</tt>, which tests
 <tt>Prop</tt> <i>once only</i> for each combination of values bound
 in enclosing <tt>?FORALL</tt>s. For example,
 <pre>?FORALL(N,nat(),?ONCEONLY(N*N &gt;= 0))</pre>
 will test that <tt>N</tt> squared is non-negative only <i>once</i>
 for each value of <tt>N</tt>. (Since <tt>nat()</tt> only generates
 small naturals, testing this example will actually give up without
 generating 100 different tests).
 <p>
 <tt>?ONCEONLY</tt> saves each generated test, and skips any
 tests which are generated for a second time---it is equivalent to
 <pre>?IMPLIES(...is a new test case...,Prop)</pre>
 Skipped tests are displayed as a <tt>'x'</tt>, just as when using
 <tt>?IMPLIES</tt>.
 </p>
 <p>Note that duplicate test cases are <i>generated</i> as usual, but
 <tt>?ONCEONLY</tt> prevents them from being <i>run</i>. This can
 save testing time if running tests is much more expensive than
 generating them. Of course, there is a space and time penalty for
 saving old tests and comparing new tests against them, so using
 <tt>?ONCEONLY</tt> will not necessarily speed up testing.
 </p>
 <p>Test cases are saved only during one run of <a href="#quickcheck-1"><code>quickcheck/1</code></a>;
 this does not prevent repetition of tests in different runs of
 <a href="#quickcheck-1"><code>quickcheck/1</code></a>.
 </p>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-aggregated_data">aggregated_data()</a></h3>
<p><tt>aggregated_data() = [{term(), integer()}]</tt></p>
<p> Aggregated data, in principle a map from terms to number of occurences.</p>

<h3 class="typedecl"><a name="type-counterexample">counterexample()</a></h3>
<p><b>abstract datatype</b>: <tt>counterexample()</tt></p>
<p> A counter-example to a QuickCheck property, which can be obtained
 using  <a href="#counterexample-0"><code>counterexample/0</code></a> or <a href="#counterexample-1"><code>counterexample/1</code></a>, and used to repeat a test,
 or test a different property in the same case. Counterexamples are represented by the values
 bound by ?FORALL--for the counterexample to make sense independently, it's important that
 these were generated without side-effects.</p>

<h3 class="typedecl"><a name="type-eqc_info_map">eqc_info_map()</a></h3>
<p><tt>eqc_info_map() = #{result =&gt; boolean() | <a href="#type-counterexample">counterexample()</a>, statistics =&gt; #{outcome =&gt; passed | failed | failed_as_expected | passed_unexpectedly | gaveup | bad_distribution, numtests =&gt; integer(), discards =&gt; integer()}, aggregated_data =&gt; [{atom(), <a href="#type-aggregated_data">aggregated_data()</a>}], measurements =&gt; [{atom(), <a href="#type-measure_map">measure_map()</a>}], user_info =&gt; <a href="#type-eqc_user_info_map">eqc_user_info_map()</a>}</tt></p>


<h3 class="typedecl"><a name="type-eqc_user_info_map">eqc_user_info_map()</a></h3>
<p><tt>eqc_user_info_map() = #{}</tt></p>
<p><p> Map containing user defined data. Data is stored using <a href="#user_info-3"><code>user_info/3</code></a>, and the result 
is a map with all keys defined by the user.</p>

 I.e. user_info(key1, data1, ...) will result in a map #{ key1 =&gt; data1, ... }.</p>

<h3 class="typedecl"><a name="type-measure_map">measure_map()</a></h3>
<p><tt>measure_map() = #{count =&gt; integer(), min =&gt; number(), max =&gt; number(), sum =&gt; number(), avg =&gt; number(), stddev =&gt; number()}</tt></p>
<p> Map containing the returned data collected by <a href="#measure-3"><code>measure/3</code></a>.</p>

<h3 class="typedecl"><a name="type-print_method">print_method()</a></h3>
<p><tt>print_method() = <a href="#type-print_method_fun">print_method_fun()</a> | {atom() | string(), none | string(), <a href="#type-print_method_fun">print_method_fun()</a>}</tt></p>
<p> Instructions on how to print statistics; either a pure <a href="print_method_fun.html"><code>print_method_fun</code></a>
 (the old way), or a triple {Tag, Title, PrintFun}. Where Tag is used to
 tag the returned statistics see <a href="#counterexample-2"><code>counterexample/2</code></a>, Title is printed as
 a header for the statistics printed by PrintFun.
 Used by <a href="#collect-3"><code>collect/3</code></a> and <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="typedecl"><a name="type-print_method_fun">print_method_fun()</a></h3>
<p><tt>print_method_fun() = fun((<a href="#type-aggregated_data">aggregated_data()</a>) -&gt; false | any())</tt></p>
<p> Printing statistics, the function is passed a list of samples and is
 expected to print statistical information about them. Print functions
 are used by <a href="#collect-3"><code>collect/3</code></a> and <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="typedecl"><a name="type-property">property()</a></h3>
<p><b>abstract datatype</b>: <tt>property()</tt></p>
<p> QuickCheck properties, which can either be boolean
 expressions, or constructed using the functions in this module.
 QuickCheck properties are tested using <a href="#quickcheck-1"><code>quickcheck/1</code></a>.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#active_users-0">active_users/0</a></td><td>Fetch a list of the currently active users of your licence.</td></tr>
<tr><td valign="top"><a href="#aggregate-2">aggregate/2</a></td><td>A property logically equivalent to <tt>Prop</tt>, but which collects a list of values in
 each test, and displays the distribution of these values once
 testing is complete.</td></tr>
<tr><td valign="top"><a href="#aggregate-3">aggregate/3</a></td><td>Like <a href="#aggregate-2"><code>aggregate/2</code></a>, but allows the user to specify how
 the collected values should be printed.</td></tr>
<tr><td valign="top"><a href="#backtrace-0">backtrace/0</a></td><td>Displays a stack backtrace from the last exception QuickCheck caught.</td></tr>
<tr><td valign="top"><a href="#check-1">check/1</a></td><td>Equivalent to <a href="#check-2"><tt>check(Prop, eqc:current_counterexample())</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#check-2">check/2</a></td><td>Tests the property in the case given.</td></tr>
<tr><td valign="top"><a href="#check-3">check/3</a></td><td>Tests the property in the case given.</td></tr>
<tr><td valign="top"><a href="#check_distribution-4">check_distribution/4</a></td><td>Check that at least a given fraction of test cases satisfy a condition.</td></tr>
<tr><td valign="top"><a href="#classify-3">classify/3</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete.</td></tr>
<tr><td valign="top"><a href="#collect-2">collect/2</a></td><td>Equivalent to <a href="#aggregate-2"><tt>aggregate([S], Prop)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#collect-3">collect/3</a></td><td>Equivalent to <a href="#aggregate-3"><tt>aggregate(PrintMethod, [S], Prop)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#conjunction-1">conjunction/1</a></td><td><tt>conjunction([{Tag1,Prop1},...,{TagN,PropN}])</tt> is a
 property which is true if <i>all</i> of the properties
 <tt>Prop1</tt>...<tt>PropN</tt> are true.</td></tr>
<tr><td valign="top"><a href="#count_values-0">count_values/0</a></td><td>A print method that displays the number of occurrences for each value
  in the collected data.</td></tr>
<tr><td valign="top"><a href="#counterexample-0">counterexample/0</a></td><td>Returns the last counter-example found.</td></tr>
<tr><td valign="top"><a href="#counterexample-1">counterexample/1</a></td><td>Equivalent to <a href="#counterexample-2"><tt>counterexample(P, [])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#counterexample-2">counterexample/2</a></td><td>Tests the property in the same way as <a href="#quickcheck-1"><code>quickcheck/1</code></a>, but if 
a test fails, then the failing test case is returned as a counterexample.</td></tr>
<tr><td valign="top"><a href="#counterexamples-0">counterexamples/0</a></td><td>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</td></tr>
<tr><td valign="top"><a href="#current_counterexample-0">current_counterexample/0</a></td><td>Returns the most recent
 counterexample found by QuickCheck.</td></tr>
<tr><td valign="top"><a href="#disjunction-1">disjunction/1</a></td><td><tt>disjunction([Prop1,...,PropN])</tt> is a property which is
 true if <i>any</i> of the properties <tt>Prop1</tt>...<tt>PropN</tt>
 is true.</td></tr>
<tr><td valign="top"><a href="#dont_print_counterexample-1">dont_print_counterexample/1</a></td><td>Suppress the normal printing of counterexamples.</td></tr>
<tr><td valign="top"><a href="#equals-2">equals/2</a></td><td>A property which holds if X and Y are equal...</td></tr>
<tr><td valign="top"><a href="#fails-1">fails/1</a></td><td>A property which succeeds when its argument fails.</td></tr>
<tr><td valign="top"><a href="#features-2">features/2</a></td><td>Attach a list of <i>features</i> to a test case, with the
  interpretation "this test case tests these features".</td></tr>
<tr><td valign="top"><a href="#force_registration-1">force_registration/1</a></td><td>
 Register a QuickCheck licence without asking questions.</td></tr>
<tr><td valign="top"><a href="#format-2">format/2</a></td><td>Can be used in place of <tt>io:format/2</tt> inside <tt>?WHENFAIL</tt>
  to allow the output to be captured by <tt>on_output/2</tt>.</td></tr>
<tr><td valign="top"><a href="#in_parallel-1">in_parallel/1</a></td><td>A property which is tested in parallel.</td></tr>
<tr><td valign="top"><a href="#in_sequence-1">in_sequence/1</a></td><td>A property which is tested sequentially.</td></tr>
<tr><td valign="top"><a href="#less_or_equal-2">less_or_equal/2</a></td><td>A property which holds if <tt>X =&lt; Y</tt>, and displays
 their values when a test fails.</td></tr>
<tr><td valign="top"><a href="#licences_installed-0">licences_installed/0</a></td><td>Returns a list of the installed licences.</td></tr>
<tr><td valign="top"><a href="#measure-3">measure/3</a></td><td>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name.</td></tr>
<tr><td valign="top"><a href="#module-1">module/1</a></td><td>Tests all the properties exported from a module, given the module name.</td></tr>
<tr><td valign="top"><a href="#module-2">module/2</a></td><td>Tests all the properties exported from a module, given options and the module name.</td></tr>
<tr><td valign="top"><a href="#numtests-2">numtests/2</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100.</td></tr>
<tr><td valign="top"><a href="#on_output-2">on_output/2</a></td><td>Supplies an output function to be used instead of io:format
  when QuickCheck generates output.</td></tr>
<tr><td valign="top"><a href="#on_test-2">on_test/2</a></td><td>Attaches a function to a property which is called every time a
  test passes or fails.</td></tr>
<tr><td valign="top"><a href="#only_top-1">only_top/1</a></td><td>A printing method for discarding all but the top N collected values.</td></tr>
<tr><td valign="top"><a href="#only_top-2">only_top/2</a></td><td>A printing method for discarding all but the top N collected values.</td></tr>
<tr><td valign="top"><a href="#quickcheck-1">quickcheck/1</a></td><td>Tests the property in 100 random cases, printing a counter-example
 if one is found.</td></tr>
<tr><td valign="top"><a href="#recheck-1">recheck/1</a></td><td>Tests the property with the <i>same</i> random number seed as
 the last failing call of <a href="#quickcheck-1"><code>quickcheck/1</code></a>.</td></tr>
<tr><td valign="top"><a href="#recheck-2">recheck/2</a></td><td>Same as <a href="#recheck-1"><code>recheck/1</code></a>, but if {with_info, true} is passed as an option
 a richer structure is returned.</td></tr>
<tr><td valign="top"><a href="#registration-1">registration/1</a></td><td>Create a QuickCheck licence for the current user, using a
 one-time use registration identifier.</td></tr>
<tr><td valign="top"><a href="#reserve-1">reserve/1</a></td><td>Reserve a QuickCheck licence for this machine.</td></tr>
<tr><td valign="top"><a href="#reserved_until-0">reserved_until/0</a></td><td>The local time that the currently active QuickCheck licence is
 reserved until.</td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Equivalent to <a href="#start-0"><tt>start()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stops the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#testing_time-2">testing_time/2</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but
  is tested continuously for <tt>T</tt> time units (by default, seconds), rather than a fixed
  number of times.</td></tr>
<tr><td valign="top"><a href="#user_info-3">user_info/3</a></td><td>Sometimes it is useful to record data deep inside a property, thus we
 provide a basic key-value store.</td></tr>
<tr><td valign="top"><a href="#version-0">version/0</a></td><td>Returns the version number of this version of QuickCheck.</td></tr>
<tr><td valign="top"><a href="#watch_shrinking-1">watch_shrinking/1</a></td><td>Repeats the most recent failed test, but displays <i>all</i>
 the test cases explored during shrinking.</td></tr>
<tr><td valign="top"><a href="#with_tag-1">with_tag/1</a></td><td>A printing method for collected data, which tags the collected
  data so that it is returned in the rich result structure from
  <a href="#counterexample-2"><code>counterexample/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#with_testing_time_unit-2">with_testing_time_unit/2</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but
  in which calls of <a href="#testing_time-2"><code>testing_time/2</code></a> measure testing time in
  units of <tt>Unit</tt> milliseconds--by default 1000.</td></tr>
<tr><td valign="top"><a href="#with_title-1">with_title/1</a></td><td>A printing method for collected data, which displays a title
  before the percentages of each value in the data.</td></tr>
<tr><td valign="top"><a href="#with_title-2">with_title/2</a></td><td>Add a title to a print method.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="active_users-0">active_users/0</a></h3>
<div class="spec">
<p><tt>active_users() -&gt; any()</tt></p>
</div><p>Fetch a list of the currently active users of your licence. The
 users are sorted by the expiry times of their current sessions; thus
 the user whose licence may first become free is first in the
 list. Of course, other users who continue running QuickCheck will
 automatically extend their sessions, so there is no guarantee that a
 licence will actually be released at the time indicated.</p>

<h3 class="function"><a name="aggregate-2">aggregate/2</a></h3>
<div class="spec">
<p><tt>aggregate(L::[term()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property logically equivalent to <tt>Prop</tt>, but which collects a list of values in
 each test, and displays the distribution of these values once
 testing is complete. A typical use would be to aggregate the list of command names generated
 by <a href="eqc_statem.html#commands-1"><code>eqc_statem:commands/1</code></a>, in order to see how often each individual
 command appeared in generated tests:
 <pre>aggregate(command_names(Cmds), ...) </pre>
 <p>
 See also <a href="#aggregate-3"><code>aggregate/3</code></a>.
 </p></p>

<h3 class="function"><a name="aggregate-3">aggregate/3</a></h3>
<div class="spec">
<p><tt>aggregate(PrintMethod::fun(([{term(), <a href="#type-int">int()</a>}]) -&gt; any()), L::[term()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Like <a href="#aggregate-2"><code>aggregate/2</code></a>, but allows the user to specify how
 the collected values should be printed. The <tt>PrintMethod</tt> parameter
 is called with a list of the collected data and the number of occurrences of each datum as an argument,
 and is expected to print some statistics. If the print method returns
 <tt>false</tt> the property fails. This is used in the implementation of
 <a href="#check_distribution-4"><code>check_distribution/4</code></a>.
 A predefined printing
 methods is provided to add a title to the statistics:
 <pre>aggregate(with_title(T),L,Prop).</pre> This is useful when a property contains
 several calls to aggregate or collect.</p>

<h3 class="function"><a name="backtrace-0">backtrace/0</a></h3>
<div class="spec">
<p><tt>backtrace() -&gt; ok</tt><br/></p>
</div><p>Displays a stack backtrace from the last exception QuickCheck caught. Note that
 this is only possible if the exception is raised in the process in which the test
 case starts. If a test case fails because of an exception in another, linked,
 process, then no backtrace is available. Calls to functions in the implementation
 of QuickCheck itself are not included in the backtrace.
 <p>If you really need to see a backtrace from a linked process, then you can do so by
 catching
 the exception yourself in that process, using erlang:get_stacktrace() to obtain the
 backtrace, and printing it yourself.</p></p>

<h3 class="function"><a name="check-1">check/1</a></h3>
<div class="spec">
<p><tt>check(Prop) -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#check-2"><tt>check(Prop, eqc:current_counterexample())</tt></a>.</p>


<h3 class="function"><a name="check-2">check/2</a></h3>
<div class="spec">
<p><tt>check(Prop::<a href="#type-property">property()</a>, Values::<a href="#type-counterexample">counterexample()</a>) -&gt; bool()</tt><br/></p>
</div><p>Tests the property in the case given. Counterexamples are generated by testing a
 property using <a href="#counterexample-1"><code>counterexample/1</code></a> or <a href="#counterexample-0"><code>counterexample/0</code></a>, and contain a list
 of the values bound by ?FORALL. A property tested by check should begin with the <i>same</i>
 sequence of ?FORALL s as the property from which the counterexample was generated, otherwise
 the results will be unpredictable. In particular, there is no check that the values
 in the counterexample could actually have been generated by the ?FORALL s in the property under
 test.
 <p><a href="#check-2"><code>check/2</code></a> can be used without a QuickCheck licence, allowing anyone to run
 tests that a licenced user has generated.</p></p>

<h3 class="function"><a name="check-3">check/3</a></h3>
<div class="spec">
<p><tt>check(Prop::<a href="#type-property">property()</a>, Values::<a href="#type-counterexample">counterexample()</a>, Options::[term()]) -&gt; bool() | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br/></p>
</div><p><p>Tests the property in the case given. Counterexamples are generated by testing a
 property using <a href="#counterexample-1"><code>counterexample/1</code></a> or <a href="#counterexample-0"><code>counterexample/0</code></a>, and contain a list
 of the values bound by ?FORALL. A property tested by check should begin with the <i>same</i>
 sequence of ?FORALL s as the property from which the counterexample was generated, otherwise
 the results will be unpredictable. In particular, there is no check that the values
 in the counterexample could actually have been generated by the ?FORALL s in the property under
 test. If <tt>{with_info, true}</tt> is passed as an Option, a richer structure is
 returned, see <a href="#counterexample-2"><code>counterexample/2</code></a>.</p>

 <p><a href="#check-3"><code>check/3</code></a> can be used without a QuickCheck licence, allowing anyone to run
 tests that a licenced user has generated.</p></p>

<h3 class="function"><a name="check_distribution-4">check_distribution/4</a></h3>
<div class="spec">
<p><tt>check_distribution(Tag::term(), Fraction::float(), Ok::boolean() | [boolean()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Check that at least a given fraction of test cases satisfy a condition.
 Unless <tt>Ok</tt> is true in at least <tt>Fraction</tt> of test cases the property fails.
 For instance, <pre>check_distribution(non_empty, 0.75, Xs /= [], Prop)</pre>
 checks that in at least 75% of test cases the list <tt>Xs</tt> is non empty. If <tt>Ok</tt>
 is a list, the distribution of the aggregated boolean values is checked (see <a href="#aggregate-2"><code>aggregate/2</code></a>).</p>

<h3 class="function"><a name="classify-3">classify/3</a></h3>
<div class="spec">
<p><tt>classify(B::bool(), S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete. If the boolean is true then the current test case is
 labelled with the term <tt>S</tt>,
 and, after testing is complete, QuickCheck prints out the percentage of
 test cases carrying each label. This can be used to check that the space
 of possible test cases has been covered reasonably well. For example,
 classifying test cases according to the length of a list enables one to
 see whether unreasonably many lists were short. Classifying
 test cases is a way to discover skewed distributions, such as can arise
 from using <tt>?IMPLIES</tt>. It is good practice to check the distribution
 of test data using <tt>classify</tt> or <a href="#collect-2"><code>collect/2</code></a>, at least while
 properties are being developed.
 <p>
 Each test case can be labelled with any number of labels: QuickCheck then
 displays the percentage of each label in the generated
 test data.
 </p>
 <p>
 Calls of classify or collect can be nested, in which case each call
 generates its own table of distributions.
 </p></p>

<h3 class="function"><a name="collect-2">collect/2</a></h3>
<div class="spec">
<p><tt>collect(S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Equivalent to <a href="#aggregate-2"><tt>aggregate([S], Prop)</tt></a>.</p>


<h3 class="function"><a name="collect-3">collect/3</a></h3>
<div class="spec">
<p><tt>collect(PrintMethod::fun(([{term(), <a href="#type-int">int()</a>}]) -&gt; any()), S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Equivalent to <a href="#aggregate-3"><tt>aggregate(PrintMethod, [S], Prop)</tt></a>.</p>


<h3 class="function"><a name="conjunction-1">conjunction/1</a></h3>
<div class="spec">
<p><tt>conjunction(Props::[{atom(), <a href="#type-property">property()</a>}]) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p><tt>conjunction([{Tag1,Prop1},...,{TagN,PropN}])</tt> is a
 property which is true if <i>all</i> of the properties
 <tt>Prop1</tt>...<tt>PropN</tt> are true. The tags are used when
 reporting counterexamples: the test case generated for each property
 is labelled with its tag in the output, together with an indication
 of whether that property passed or failed. Shrinking discards
 tags and properties which do not contribute to the test failure.</p>

<h3 class="function"><a name="count_values-0">count_values/0</a></h3>
<div class="spec">
<p><tt>count_values() -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p>A print method that displays the number of occurrences for each value
  in the collected data. It is intended to be passed to <a href="#collect-3"><code>collect/3</code></a> or
  <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="counterexample-0">counterexample/0</a></h3>
<div class="spec">
<p><tt>counterexample() -&gt; undefined | <a href="#type-counterexample">counterexample()</a></tt><br/></p>
</div><p>Returns the last counter-example found. See <a href="#counterexample-1"><code>counterexample/1</code></a>.</p>

<h3 class="function"><a name="counterexample-1">counterexample/1</a></h3>
<div class="spec">
<p><tt>counterexample(P::<a href="#type-property">property()</a>) -&gt; true | <a href="#type-counterexample">counterexample()</a></tt><br/></p>
</div><p>Equivalent to <a href="#counterexample-2"><tt>counterexample(P, [])</tt></a>.</p>


<h3 class="function"><a name="counterexample-2">counterexample/2</a></h3>
<div class="spec">
<p><tt>counterexample(P::<a href="#type-property">property()</a>, Option::[term()]) -&gt; true | <a href="#type-counterexample">counterexample()</a> | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br/></p>
</div><p><p>Tests the property in the same way as <a href="#quickcheck-1"><code>quickcheck/1</code></a>, but if 
a test fails, then the failing test case is returned as a counterexample.</p>

 If <tt>{with_info, true}</tt> is passed as an option, an even richer structure
 is returned, namely an <a href="eqc_info_map.html"><code>eqc_info_map</code></a>. The returned map contains the
 following fields:
 <ul>
 <li><b>result -</b> what <a href="#counterexample-1"><code>counterexample/1</code></a> would return</li>
 <li><b>statistics -</b> A map containing, <tt>outcome</tt> of the test as well as the number of executed
 tests (<tt>numtests</tt>) and discarded tests (<tt>discards</tt>). If the test fails
 it also contains successful shrink steps (<tt>shrinksteps</tt>) and failed shrink steps
 (<tt>failed_shrinksteps</tt>).</li>
 <li><b>aggregated_data -</b> all aggregated data (<a href="#collect-3"><code>collect/3</code></a>/<a href="#aggregate-3"><code>aggregate/3</code></a>/<a href="#classify-3"><code>classify/3</code></a>)
 that has a tag is put into this field. Aggregated data is tagged by using <a href="#with_tag-1"><code>with_tag/1</code></a>
 or <a href="with_title.html"><code>with_title</code></a> as its print method.</li>
 <li><b>measurements -</b> Data collected by <a href="#measure-3"><code>measure/3</code></a>, formatted as a <a href="measure_map.html"><code>measure_map</code></a>.</li>
 <li><b>user_info -</b> Data collected by ?USER_INFO in the property, format is a <a href="eqc_user_info_map.html"><code>eqc_user_info_map</code></a>.</li>
 </ul></p>

<h3 class="function"><a name="counterexamples-0">counterexamples/0</a></h3>
<div class="spec">
<p><tt>counterexamples() -&gt; [{atom(), <a href="#type-counterexample">counterexample()</a>}]</tt><br/></p>
</div><p>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</p>

<h3 class="function"><a name="current_counterexample-0">current_counterexample/0</a></h3>
<div class="spec">
<p><tt>current_counterexample() -&gt; <a href="#type-counterexample">counterexample()</a></tt><br/></p>
</div><p>Returns the most recent
 counterexample found by QuickCheck. This can be used while
 QuickCheck is shrinking a failed test case to follow progress, or if
 shrinking must be interrupted, to recover the last failed test case
 that QuickCheck had found. The counterexample is fetched from a file
 in the current directory.</p>

<h3 class="function"><a name="disjunction-1">disjunction/1</a></h3>
<div class="spec">
<p><tt>disjunction(Props::[<a href="#type-property">property()</a>]) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p><tt>disjunction([Prop1,...,PropN])</tt> is a property which is
 true if <i>any</i> of the properties <tt>Prop1</tt>...<tt>PropN</tt>
 is true. <tt>disjunction</tt> tests the properties from
 left-to-right, and stops as soon as one of them passes.</p>

<h3 class="function"><a name="dont_print_counterexample-1">dont_print_counterexample/1</a></h3>
<div class="spec">
<p><tt>dont_print_counterexample(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Equivalent to <a href="eqc_gen.html#with_parameter-3"><tt>eqc_gen:with_parameter(print_counterexample, false,
		       Prop)</tt></a>.</p>
<p>Suppress the normal printing of counterexamples. Custom counterexample
  printing can be added using <tt>?WHENFAIL</tt>.</p>

<h3 class="function"><a name="equals-2">equals/2</a></h3>
<div class="spec">
<p><tt>equals(X::any(), Y::any()) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property which holds if X and Y are equal... and displays
 their values when a test fails.</p>

<h3 class="function"><a name="fails-1">fails/1</a></h3>
<div class="spec">
<p><tt>fails(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property which succeeds when its argument fails.
 Sometimes it is useful to write down properties which do <i>not</i> hold
 (even though one might expect them to). This can help prevent misconceptions.
 <tt>fails(P)</tt> is tested in the same way as <tt>P</tt>, but
 fails only if <tt>P</tt> <i>succeeds</i> for every test. Thus
 <tt>fails(P)</tt> declares that QuickCheck should be able to find
 a counter-example to property <tt>P</tt>.</p>

<h3 class="function"><a name="features-2">features/2</a></h3>
<div class="spec">
<p><tt>features(Fs::[any()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Attach a list of <i>features</i> to a test case, with the
  interpretation "this test case tests these features". For example,
  the features might be lines of code covered by the test case, or
  argument values that were tested, or success/failure of individual
  functions. Features can be used to generate test suites that cover
  all of the features encountered. See <a href="eqc_suite.html#feature_based-1"><code>eqc_suite:feature_based/1</code></a> for details.</p>

<h3 class="function"><a name="force_registration-1">force_registration/1</a></h3>
<div class="spec">
<p><tt>force_registration(X1) -&gt; any()</tt></p>
</div><p>
 Register a QuickCheck licence without asking questions.
 This function is useful when scripting user registration, but dangerous
 since licences may only be registered once!
 Note that it takes a list of exactly once licence to enable use with
 erl -run force_registration LicenceId</p>

<h3 class="function"><a name="format-2">format/2</a></h3>
<div class="spec">
<p><tt>format(Fmt::string(), Args::[term()]) -&gt; ok</tt><br/></p>
</div><p>Can be used in place of <tt>io:format/2</tt> inside <tt>?WHENFAIL</tt>
  to allow the output to be captured by <tt>on_output/2</tt>.</p>

<h3 class="function"><a name="in_parallel-1">in_parallel/1</a></h3>
<div class="spec">
<p><tt>in_parallel(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property which is tested in parallel.</p>

<h3 class="function"><a name="in_sequence-1">in_sequence/1</a></h3>
<div class="spec">
<p><tt>in_sequence(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property which is tested sequentially. Takes priority over <a href="#in_parallel-1"><code>in_parallel/1</code></a>.</p>

<h3 class="function"><a name="less_or_equal-2">less_or_equal/2</a></h3>
<div class="spec">
<p><tt>less_or_equal(X::any(), Y::any()) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>A property which holds if <tt>X =&lt; Y</tt>, and displays
 their values when a test fails.</p>

<h3 class="function"><a name="licences_installed-0">licences_installed/0</a></h3>
<div class="spec">
<p><tt>licences_installed() -&gt; any()</tt></p>
</div><p>Returns a list of the installed licences.</p>

<h3 class="function"><a name="measure-3">measure/3</a></h3>
<div class="spec">
<p><tt>measure(Name::atom() | string(), X::number() | [number()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name. X can also be a list of values,
 in which case all of them are included in the measurements.</p>

<h3 class="function"><a name="module-1">module/1</a></h3>
<div class="spec">
<p><tt>module(Mod::atom()) -&gt; [atom()]</tt><br/></p>
</div><p>Tests all the properties exported from a module, given the module name.
 Any function with arity zero whose name begins with "prop_" is treated as a
 property. The result is a list of the names of the properties that
 failed. See also <a href="#module-2"><code>module/2</code></a>.</p>

<h3 class="function"><a name="module-2">module/2</a></h3>
<div class="spec">
<p><tt>module(Options::any(), Mod::atom()) -&gt; [atom()]</tt><br/></p>
</div><p>Tests all the properties exported from a module, given options and the module name.
 Any function with arity zero whose name begins with "prop_" is treated as a
 property. The result is a list of the names of the properties that failed.
 <p>
 The <tt>Options</tt> parameter can be a single option, or a list of
 options. Each option represents a function to be applied to each
 property before it is tested, and can either be a fun value, an atom
 (representing a function exported from module <tt>eqc</tt>), or a
 tuple of an atom and some arguments (representing a function
 exported by module <tt>eqc</tt> taking additional arguments before
 the property).
 </p><p><b>Example</b><br/>
 To test every property in a module 1,000 times, use
 <pre>
 eqc:module({numtests,1000},ModuleName).
 </pre>
 </p><p><b>Testing budget</b></p><p>
 Using the <tt>testing_time</tt> option (thus calling <code>eqc:testing_time/2</code>)
 one can set a fixed testing time for each property. This is quite inflexible,
 however, and often you want different testing times for different properties
 and you don't want the total time to depend on the number of properties in
 the module. For this purpose there is a special option <tt>{testing_budget,
 Seconds}</tt> which controls the total time available for testing. By default
 the testing budget is distributed uniformly among the properties, but the
 distribution can be controlled by defining the <tt>property_weight/2</tt>
 callback. This takes a testing profile and a property name as arguments and
 returns the relative weight for the property. The testing profile can be set
 with the <tt>{testing_profile, Profile}</tt> option and can be any Erlang
 term.

 </p><p><b>Example</b><br/>
 Here is a simple example with two properties and two testing profiles.
 <pre>
 -module(example_eqc).
 -compile(export_all).

 prop_a() -&gt; ...
 prop_b() -&gt; ...

 property_weight(more_a, prop_a) -&gt; 3;
 property_weight(more_b, prop_b) -&gt; 3;
 property_weight(_, _) -&gt; 1.
 </pre>
 Now we can choose the testing profile to decide how much time to spend on
 each property.
 <pre>
 1&gt; eqc:module({testing_budget, 60}, example_eqc).
 prop_a: .....
 Time limit reached: 30.0 seconds.
 OK, passed 204 tests
 prop_b: .....
 Time limit reached: 30.0 seconds.
 OK, passed 213 tests
 []
 2&gt; eqc:module([{testing_budget, 60}, {testing_profile, more_a}], example_eqc).
 prop_a: .....
 Time limit reached: 45.0 seconds.
 OK, passed 298 tests
 prop_b: .....
 Time limit reached: 15.0 seconds.
 OK, passed 102 tests
 []
 3&gt; eqc:module([{testing_budget, 60}, {testing_profile, more_b}], example_eqc).
 prop_a: .....
 Time limit reached: 15.0 seconds.
 OK, passed 96 tests
 prop_b: .....
 Time limit reached: 45.0 seconds.
 OK, passed 311 tests
 []
 </pre>
 </p></p>

<h3 class="function"><a name="numtests-2">numtests/2</a></h3>
<div class="spec">
<p><tt>numtests(N::<a href="#type-nat">nat()</a>, Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100.
  <p>It is also possible to specify <tt>{min,N}</tt> or
  <tt>{max,N}</tt> as the number of tests, in which case we run
  <i>at least</i> <tt>N</tt> tests, or <i>at most</i>
  <tt>N</tt> tests, but otherwise according to the time limits or
  <a href="#numtests-2"><code>numtests/2</code></a> specified in the rest of the property.</p></p>

<h3 class="function"><a name="on_output-2">on_output/2</a></h3>
<div class="spec">
<p><tt>on_output(Fun::fun((string(), [term()]) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Supplies an output function to be used instead of io:format
  when QuickCheck generates output. All output generated by
  QuickCheck is passed to <tt>Fun</tt>, in the form of a format
  string and a list of terms--the same arguments expected by
  <tt>io:format</tt>. By supplying a function which does nothing,
  QuickCheck can be run silently. By supplying a function which
  writes to a file, all QuickCheck output can be saved.
  <p>Note that output generated by user code is <i>not</i> passed to
  this output function. For example, calls to io:format in the
  property, or in the code under test, will generate output in the
  shell as usual. This applies even to calls inside a
  <tt>?WHENFAIL</tt>, although this output can be redirected by replacing
  calls to <tt>io:format</tt> by calls to <tt>eqc:format/2</tt>. If you want
  to redirect output outside of <tt>?WHENFAIL</tt>, then you need to modify
  your own code appropriately.</p>
  <p>The reason that <tt>Fun</tt> is passed a format string and
  arguments, rather than an already formatted string, is to make it
  easier to extract information from the output without parsing
  it. However, there is no guarantee that different versions of
  QuickCheck will use the same format strings and term lists--you use
  this information at your own risk, in other words.</p></p>

<h3 class="function"><a name="on_test-2">on_test/2</a></h3>
<div class="spec">
<p><tt>on_test(Fun::fun((<a href="#type-counterexample">counterexample()</a>, bool()) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Attaches a function to a property which is called every time a
  test passes or fails. The arguments are the test case (a list of
  values), and a boolean indicating whether or not the test
  passed. Tests which are skipped (because of an
  <tt>?IMPLIES(false,...)</tt>) are not included.</p>

<h3 class="function"><a name="only_top-1">only_top/1</a></h3>
<div class="spec">
<p><tt>only_top(N::integer()) -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p>A printing method for discarding all but the top N collected values.
  Discarded values are grouped together into an entry labelled '...'. The
  resulting print method is intended to be passed to <a href="#collect-3"><code>collect/3</code></a> or
  <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="only_top-2">only_top/2</a></h3>
<div class="spec">
<p><tt>only_top(N::integer(), F::<a href="#type-print_method">print_method()</a>) -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p>A printing method for discarding all but the top N collected values.
  Discarded values are grouped together into an entry labelled '...'. The
  second argument is a print method for the pruned data, such as <a href="#with_title-1"><code>with_title/1</code></a>. The resulting print method is intended to be passed to <a href="#collect-3"><code>collect/3</code></a> or <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="quickcheck-1">quickcheck/1</a></h3>
<div class="spec">
<p><tt>quickcheck(P::<a href="#type-property">property()</a>) -&gt; bool()</tt><br/></p>
</div><p>Tests the property in 100 random cases, printing a counter-example
 if one is found. Initially small test cases are generated, then the
 size increases as testing progresses (see <a href="eqc_gen.html"><code>eqc_gen</code></a>, <tt>?SIZED</tt>,
 <a href="eqc_gen.html#resize-2"><code>eqc_gen:resize/2</code></a> for the way size affects test data generation).
 The result is <tt>true</tt> if all tests succeeded (or if one failed,
 and failure was expected). On success, <tt>quickcheck</tt> analyses
 the distribution of test case labels. On failure, <tt>quickcheck</tt>
 tries to simplify the counter-example found as far as possible (see <i>
 shrinking</i>, described in <a href="eqc_gen.html"><code>eqc_gen</code></a>).</p>

<h3 class="function"><a name="recheck-1">recheck/1</a></h3>
<div class="spec">
<p><tt>recheck(Prop::<a href="#type-property">property()</a>) -&gt; bool()</tt><br/></p>
</div><p>Tests the property with the <i>same</i> random number seed as
 the last failing call of <a href="#quickcheck-1"><code>quickcheck/1</code></a>. If the property is
 the same as in that last call, then the same test case will be
 generated. Note that recheck repeats the test <i>and its
 shrinking</i>. This can be used to adjust the shrinking strategy in
 the property, then reshrink the same counterexample, perhaps to a
 better result. If you just
 want to repeat the <i>shrunk</i> test, then use
 <pre>eqc:check(Prop,eqc:counterexample())</pre> instead.</p>

<h3 class="function"><a name="recheck-2">recheck/2</a></h3>
<div class="spec">
<p><tt>recheck(Prop::<a href="#type-property">property()</a>, Options::[term()]) -&gt; boolean() | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br/></p>
</div><p>Same as <a href="#recheck-1"><code>recheck/1</code></a>, but if {with_info, true} is passed as an option
 a richer structure is returned. See <a href="#counterexample-2"><code>counterexample/2</code></a> for a description of
 the return format.</p>

<h3 class="function"><a name="registration-1">registration/1</a></h3>
<div class="spec">
<p><tt>registration(LicenceId) -&gt; any()</tt></p>
</div><p>Create a QuickCheck licence for the current user, using a
 one-time use registration identifier. Note that using the same
 registration identifier twice will invalidate it---if you do this,
 ask your licence administrator to <i>reset</i> your licence for you.
 <p> Each registration identifier is associated with a licence name,
 usually the name of the licence owner, such as "Quviq AB". It is
 possible to register <i>several</i> identifiers with different
 licence names, which makes it possible to use different licences on
 different occasions. If you are registered as a user of more than
 one licence, then you will need to create a preferences file called
 .eqc_licence to specify which licence you want to use. This file can
 be placed in your home directory, or locally in the directory in
 which you are running QuickCheck, or one of its parent
 directories. A local file takes precedence over the one in your home
 directory.  </p><p> The .eqc_licence file can just contain the name
 of the licence you want to use, or the names of several licences,
 one per line. In the latter case, QuickCheck tries each licence in
 turn, using the first one that enables a successful start. A warning
 is generated for each licence name (mentioned in this file) for
 which no registration identifier is installed. The warning can be
 disabled by appending a '?' to the licence name.</p></p>

<h3 class="function"><a name="reserve-1">reserve/1</a></h3>
<div class="spec">
<p><tt>reserve(Period) -&gt; any()</tt></p>
</div><p><p>Reserve a QuickCheck licence for this machine. Reservations can 
be made for up to seven days; once a licence is reserved, it cannot 
be used on another machine until the reservation has 
expired. Reserving a floating licence can be useful to ensure that 
another user does not begin using it at a critical time, or, since a 
reserved licence can be used without internet access, to prepare a 
laptop for a trip during which internet access will not be 
available.</p>

 <p>Examples: eqc:reserve({3,days}), eqc:reserve({6,hours}), 
eqc:reserve(5). (If the unit, days or hours, is not specified, then 
it defaults to days).</p>

 This call always succeeds, and returns {reserved_until,Time}, where
 Time is the local time the licence is now reserved until.</p>

<h3 class="function"><a name="reserved_until-0">reserved_until/0</a></h3>
<div class="spec">
<p><tt>reserved_until() -&gt; any()</tt></p>
</div><p>The local time that the currently active QuickCheck licence is
 reserved until.</p>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; pid()</tt><br/></p>
</div><p><p>Starts the QuickCheck server. If it is already running on this 
node, nothing is done.</p>

 Each user can run only one instance of the QuickCheck server at a
 time. If the server is already running on another Erlang node, it
 will be terminated automatically.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Dummy) -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#start-0"><tt>start()</tt></a>.</p>


<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; any()</tt></p>
</div><p>Stops the QuickCheck server.
 QuickCheck properties are tested in the QuickCheck server process, which is
 spawned automatically when quickcheck is first called. Usually there is no
 need to stop the QuickCheck server explicitly, but if a need does arise
 then this function can be used.</p>

<h3 class="function"><a name="testing_time-2">testing_time/2</a></h3>
<div class="spec">
<p><tt>testing_time(T::<a href="#type-nat">nat()</a>, Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but
  is tested continuously for <tt>T</tt> time units (by default, seconds), rather than a fixed
  number of times. This can be used to apportion available testing
  time among a set of properties. When the time limit is reached,
  then no more tests are started, but any currently running test is completed.
  <p>The time unit can be specified using <a href="#with_testing_time_unit-2"><code>with_testing_time_unit/2</code></a>.</p>
  <p>It is also possible to specify <tt>{min,Time}</tt> or
  <tt>{max,Time}</tt> as the time limit, in which case tests are run
  for <i>at least</i> <tt>Time</tt> time units, or <i>at most</i>
  <tt>Time</tt> units, but otherwise according to the time limits or
  <a href="#numtests-2"><code>numtests/2</code></a> specified in the rest of the property.</p></p>

<h3 class="function"><a name="user_info-3">user_info/3</a></h3>
<div class="spec">
<p><tt>user_info(Key::atom(), FunOrData::fun((any()) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Sometimes it is useful to record data deep inside a property, thus we
 provide a basic key-value store. Either some static piece of data can be
 stored for <tt>Key</tt>, if <tt>DataOrFun</tt> is not a function. Otherwise
 the function (with arity 1) in <tt>DataOrFun</tt> is applied to whatever data
 is stored for <tt>Key</tt>, if no data is yet stored the function is applied
 to <tt>undefined</tt>.
 <pre>
   prop_ok() -&gt;
     ?FORALL(X, nat(),
       user_info(sum, fun(undefined) -&gt; X; (Sum) -&gt; Sum + X end, ...)).
 </pre>
 If this property is tested with <a href="#counterexample-2"><code>counterexample/2</code></a> passing
 <tt>{with_info, true}</tt> as an option it will result in a result map where
 <tt>user_info</tt> is a map containing the key <tt>sum</tt> and the value
 will be the total sum of all tested values (including shrunk values if the
 property fails!). The rich result is further described for <a href="#counterexample-2"><code>counterexample/2</code></a>.</p>

<h3 class="function"><a name="version-0">version/0</a></h3>
<div class="spec">
<p><tt>version() -&gt; any()</tt></p>
</div><p>Returns the version number of this version of QuickCheck.</p>

<h3 class="function"><a name="watch_shrinking-1">watch_shrinking/1</a></h3>
<div class="spec">
<p><tt>watch_shrinking(P::<a href="#type-property">property()</a>) -&gt; ok</tt><br/></p>
</div><p>Repeats the most recent failed test, but displays <i>all</i>
 the test cases explored during shrinking. The test cases are reported in the order they are
 tried, so each Failed test is followed by attempts to shrink it, while each OK test
 (or test skipped because a precondition failed) is
 followed by an alternative way to shrink the last Failed test. The last Failed test displayed
 is the final result of shrinking.</p>

<h3 class="function"><a name="with_tag-1">with_tag/1</a></h3>
<div class="spec">
<p><tt>with_tag(Tag::atom() | string()) -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p>A printing method for collected data, which tags the collected
  data so that it is returned in the rich result structure from
  <a href="#counterexample-2"><code>counterexample/2</code></a>. It is intended to be
  passed to <a href="#collect-3"><code>collect/3</code></a> or <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="with_testing_time_unit-2">with_testing_time_unit/2</a></h3>
<div class="spec">
<p><tt>with_testing_time_unit(Unit::<a href="#type-nat">nat()</a>, Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but
  in which calls of <a href="#testing_time-2"><code>testing_time/2</code></a> measure testing time in
  units of <tt>Unit</tt> milliseconds--by default 1000. If <a href="#testing_time-2"><code>testing_time/2</code></a> is used to apportion available testing time between
  properties, then <a href="#with_testing_time_unit-2"><code>with_testing_time_unit/2</code></a> can be used as a
  property wrapper to increase or decrease the total time spent testing.</p>

<h3 class="function"><a name="with_title-1">with_title/1</a></h3>
<div class="spec">
<p><tt>with_title(Title::atom() | string()) -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p><p>A printing method for collected data, which displays a title
  before the percentages of each value in the data. It is intended to be
  passed to <a href="#collect-3"><code>collect/3</code></a> or <a href="#aggregate-3"><code>aggregate/3</code></a>.</p>
 
  The function also tags the collected data (with the title) so that it
  is returned in the rich result structure from <a href="#counterexample-2"><code>counterexample/2</code></a>.</p>

<h3 class="function"><a name="with_title-2">with_title/2</a></h3>
<div class="spec">
<p><tt>with_title(Title::atom() | string(), Fun::<a href="#type-print_method">print_method()</a>) -&gt; <a href="#type-print_method">print_method()</a></tt><br/></p>
</div><p>Add a title to a print method. The title is printed before the print
  method is called.</p>
<hr/>

<div class="navbar"><a name="#navbar_bottom"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<p><i>Generated by EDoc, Jun 13 2017, 10:20:27.</i></p>
</body>
</html>
